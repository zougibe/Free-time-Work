<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Sign Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: "class",
        };
    </script>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
        }

        .sidebar {
            transition: transform 0.3s ease;
            z-index: 40;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                position: fixed;
                top: 0;
                left: 0;
                width: 85%;
                max-width: 320px;
                height: 100vh;
            }

            .sidebar.open {
                transform: translateX(0);
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
            }

            .main-content {
                margin-left: 0 !important;
            }

            .sidebar.open+.main-content #mobile-menu-btn {
                left: calc(85% - 2rem);
            }
        }

        /* Improved glow effect */
        .glow-effect {
            position: relative;
        }

        .glow-effect::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: currentColor;
            opacity: 0.3;
            filter: blur(15px);
            z-index: -1;
            border-radius: inherit;
        }

        /* Overlay for mobile when sidebar is open */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 30;
        }

        .sidebar-overlay.open {
            display: block;
        }

        /* Smooth transitions for mobile menu button */
        #mobile-menu-btn {
            transition: left 0.3s ease, transform 0.3s ease;
            z-index: 50;
        }
    </style>
</head>

<body class="bg-gray-100 dark:bg-gray-900">
    <!-- Sidebar Overlay (mobile only) -->
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <!-- Sidebar -->
    <aside class="sidebar fixed top-0 left-0 w-80 h-screen bg-gray-50 dark:bg-gray-800 p-4 overflow-y-auto">
        <header class="mb-5 border-b pb-3 border-gray-200 dark:border-gray-700">
            <h1 class="text-2xl font-bold text-gray-800 dark:text-white">
                Neon Sign Designer
            </h1>
            <p class="text-sm text-gray-600 dark:text-gray-300">
                Create vibrant neon signs for any setting
            </p>
        </header>

        <!-- Text Input -->
        <div class="mb-5">
            <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2">
                Sign Text
            </h2>
            <input id="sign-text" type="text" placeholder="Your sign text"
                class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white">
        </div>

        <!-- Font Selection -->
        <div class="mb-5">
            <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2">
                Font
            </h2>
            <select id="font-select"
                class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white">
                <option value="helvetiker">Helvetiker</option>
                <option value="optimer">Optimer</option>
                <option value="gentilis">Gentilis</option>
            </select>
        </div>

        <!-- Color Selection -->
        <div class="mb-5">
            <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2">
                Neon Color
            </h2>
            <div class="grid grid-cols-4 gap-2">
                <button data-color="#FF0000" class="color-btn w-full h-10 bg-red-500 rounded-lg glow-effect"></button>
                <button data-color="#00FF00" class="color-btn w-full h-10 bg-green-500 rounded-lg glow-effect"></button>
                <button data-color="#0000FF" class="color-btn w-full h-10 bg-blue-500 rounded-lg glow-effect"></button>
                <button data-color="#FFFF00"
                    class="color-btn w-full h-10 bg-yellow-400 rounded-lg glow-effect"></button>
                <button data-color="#FF00FF" class="color-btn w-full h-10 bg-pink-500 rounded-lg glow-effect"></button>
                <button data-color="#00FFFF" class="color-btn w-full h-10 bg-cyan-400 rounded-lg glow-effect"></button>
                <button data-color="#FF6600"
                    class="color-btn w-full h-10 bg-orange-500 rounded-lg glow-effect"></button>
                <button data-color="#9900FF"
                    class="color-btn w-full h-10 bg-purple-600 rounded-lg glow-effect"></button>
            </div>
            <div class="mt-2">
                <label class="text-sm text-gray-600 dark:text-gray-300">Custom Color:</label>
                <input id="custom-color" type="color" class="w-full mt-1 h-10 rounded-lg">
            </div>
        </div>

        <!-- Effects -->
        <div class="mb-5">
            <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2">
                Effects
            </h2>
            <div class="flex flex-col space-y-4">
                <label class="inline-flex items-center cursor-pointer">
                    <input id="pulse-effect" type="checkbox" value="" class="sr-only peer">
                    <div
                        class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-pink-300 dark:peer-focus:ring-pink-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-pink-600 dark:peer-checked:bg-pink-600">
                    </div>
                    <span class="ms-3 text-sm font-medium text-gray-700 dark:text-gray-300">Pulsing Glow</span>
                </label>
                <label class="inline-flex items-center cursor-pointer">
                    <input id="flicker-effect" type="checkbox" value="" class="sr-only peer">
                    <div
                        class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 dark:peer-focus:ring-purple-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-purple-600 dark:peer-checked:bg-purple-600">
                    </div>
                    <span class="ms-3 text-sm font-medium text-gray-700 dark:text-gray-300">Random Flicker</span>
                </label>
                <label class="inline-flex items-center cursor-pointer">
                    <input id="reflection-effect" type="checkbox" value="" class="sr-only peer">
                    <div
                        class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 dark:peer-focus:ring-indigo-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-indigo-600 dark:peer-checked:bg-indigo-600">
                    </div>
                    <span class="ms-3 text-sm font-medium text-gray-700 dark:text-gray-300">Surface Reflection</span>
                </label>
                <label class="inline-flex items-center cursor-pointer">
                    <input id="preview-mode" type="checkbox" value="" class="sr-only peer">
                    <div
                        class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-teal-300 dark:peer-focus:ring-teal-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-teal-600 dark:peer-checked:bg-teal-600">
                    </div>
                    <span class="ms-3 text-sm font-medium text-gray-700 dark:text-gray-300">Preview Mode</span>
                </label>
            </div>
        </div>

        <!-- Preview Environment (hidden by default) -->
        <div id="preview-environment" class="mb-5 hidden">
            <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2">
                Preview Environment
            </h2>
            <div class="grid grid-cols-1 gap-2">
                <button data-environment="diner"
                    class="environment-btn bg-indigo-100 hover:bg-indigo-200 dark:bg-indigo-900 dark:hover:bg-indigo-800 text-indigo-800 dark:text-indigo-200 p-2 rounded-lg text-sm flex items-center justify-center">
                    <i class="fas fa-utensils mr-2"></i> Retro Diner
                </button>
                <button data-environment="cyberpunk"
                    class="environment-btn bg-purple-100 hover:bg-purple-200 dark:bg-purple-900 dark:hover:bg-purple-800 text-purple-800 dark:text-purple-200 p-2 rounded-lg text-sm flex items-center justify-center">
                    <i class="fas fa-city mr-2"></i> Cyberpunk Alley
                </button>
                <button data-environment="festival"
                    class="environment-btn bg-pink-100 hover:bg-pink-200 dark:bg-pink-900 dark:hover:bg-pink-800 text-pink-800 dark:text-pink-200 p-2 rounded-lg text-sm flex items-center justify-center">
                    <i class="fas fa-music mr-2"></i> Music Festival
                </button>
            </div>
        </div>

        <!-- Visual Pop Score -->
        <div
            class="mb-5 p-3 bg-gradient-to-r from-indigo-100 to-purple-100 dark:from-indigo-900 dark:to-purple-900 rounded-lg">
            <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-1">
                Visual Pop Score
            </h2>
            <div class="flex items-center">
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                    <div id="pop-score-bar" class="bg-gradient-to-r from-pink-500 to-purple-600 h-4 rounded-full"
                        style="width: 70%"></div>
                </div>
                <span id="pop-score" class="ml-2 text-gray-700 dark:text-gray-200 font-bold">7.0</span>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="grid grid-cols-2 gap-3">
            <button id="save-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-lg">
                <i class="fas fa-save mr-1"></i> Save Design
            </button>
            <button id="export-btn"
                class="bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-lg">
                <i class="fas fa-download mr-1"></i> Export PNG
            </button>
        </div>

        <!-- Saved Designs -->
        <div class="mt-5">
            <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2">
                Saved Designs
            </h2>
            <div id="saved-designs" class="grid grid-cols-2 gap-2">
                <!-- Saved designs will appear here -->
            </div>
        </div>
    </aside>

    <!-- Main Content -->
    <div class="main-content ml-80 bg-gray-100 dark:bg-gray-900 h-screen">
        <!-- Canvas Container -->
        <div id="canvas-container" class="w-full h-full">
            <!-- ThreeJS Scene Here -->
        </div>

        <!-- Mobile Menu Button - Fixed position and always visible -->
        <button id="mobile-menu-btn"
            class="md:hidden fixed top-4 left-4 z-50 bg-white/90 dark:bg-gray-800/90 text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 rounded-full w-10 h-10 flex items-center justify-center shadow-lg transition-all duration-300">
            <i class="fas fa-bars" id="menu-icon"></i>
        </button>

        <!-- Dark Mode Toggle -->
        <button id="theme-toggle"
            class="fixed top-4 right-4 z-30 bg-white/90 dark:bg-gray-800/90 text-yellow-600 dark:text-yellow-400 hover:text-yellow-800 dark:hover:text-yellow-300 rounded-full w-10 h-10 flex items-center justify-center shadow-lg">
            <i class="fas fa-sun dark:hidden"></i>
            <i class="fas fa-moon hidden dark:inline"></i>
        </button>
    </div>

    <script>
        // Global variables
        const neonElements = [];
        let scene, camera, renderer, controls, textMesh, glowMesh;
        let currentColor = "#FF0000";
        let currentFont = "helvetiker";
        let isPulsing = false;
        let isFlickering = false;
        let hasReflection = false;
        let isPreviewMode = false;
        let currentEnvironment = "diner";
        let popScore = 7.0;
        let fontLoader, font;
        let originalCameraPosition = { x: 0, y: 1, z: 5 };
        let originalControlsState = {
            enableRotate: true,
            minDistance: 2,
            maxDistance: 10,
        };

        // Theme colors
        const themeColors = {
            light: 0xf0f0f0,
            dark: 0x333333,
        };

        // Environment background images
        const environmentImages = {
            diner: "https://images.unsplash.com/photo-1707862313123-031db8cdd46e?q=80&w=2567&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
            cyberpunk: "https://images.unsplash.com/photo-1663511174032-870c8e560a1e?q=80&w=2670&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
            festival: "https://images.unsplash.com/photo-1450044804117-534ccd6e6a3a?q=80&w=2574&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
        };

        // Initialize when DOM is fully loaded
        document.addEventListener("DOMContentLoaded", init);

        function init() {
            console.log("Initializing neon sign designer...");
            try {
                setupThreeJS();
                setupEventListeners();
                loadFonts();
                loadSavedDesigns();

                // Check for dark mode preference
                if (
                    localStorage.getItem("darkMode") === "true" ||
                    window.matchMedia("(prefers-color-scheme: dark)").matches
                ) {
                    document.documentElement.classList.add("dark");
                }

                // Check for mobile view
                checkMobileView();

                // Listen for window resize
                window.addEventListener('resize', onWindowResize);

                animate();
            } catch (error) {
                console.error("Initialization error:", error);
            }
        }

        function checkMobileView() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            const menuIcon = document.getElementById('menu-icon');
            const mobileBtn = document.getElementById('mobile-menu-btn');

            if (window.innerWidth < 768) {
                // Mobile view - hide sidebar by default
                sidebar.classList.remove('open');
                overlay.classList.remove('open');
                menuIcon.classList.remove('fa-times');
                menuIcon.classList.add('fa-bars');
                mobileBtn.style.left = '1rem';
                updateRendererSize();
            } else {
                // Desktop view - show sidebar
                sidebar.classList.add('open');
                overlay.classList.remove('open');
                menuIcon.classList.remove('fa-times');
                menuIcon.classList.add('fa-bars');
                mobileBtn.style.left = '1rem';
                updateRendererSize();
            }
        }

        function updateRendererSize() {
            if (!renderer || !camera) return;

            const sidebar = document.querySelector('.sidebar');
            const isMobile = window.innerWidth < 768;

            if (isMobile) {
                // Full width for mobile
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
            } else {
                // Account for sidebar width if open
                const width = sidebar.classList.contains('open') ? window.innerWidth - 320 : window.innerWidth;
                renderer.setSize(width, window.innerHeight);
                camera.aspect = width / window.innerHeight;
            }

            camera.updateProjectionMatrix();
        }

        function onWindowResize() {
            checkMobileView();
        }

        function setupThreeJS() {
            // Create scene
            scene = new THREE.Scene();

            // Set background based on theme
            const isDarkMode = document.documentElement.classList.contains("dark");
            scene.background = new THREE.Color(
                isDarkMode ? themeColors.dark : themeColors.light
            );

            // Create camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1, 5);
            originalCameraPosition = { x: 0, y: 1, z: 5 };

            // Create renderer with error handling
            const container = document.getElementById("canvas-container");
            if (!container) {
                throw new Error("Canvas container element not found");
            }

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });

            // Set initial renderer size
            updateRendererSize();
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 10;

            // Store original controls state
            originalControlsState = {
                enableRotate: controls.enableRotate,
                minDistance: controls.minDistance,
                maxDistance: controls.maxDistance,
            };

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Point light for better neon effect
            const pointLight = new THREE.PointLight(0xffffff, 1, 10);
            pointLight.position.set(0, 0, 2);
            scene.add(pointLight);

            // Add floor with grid
            createFloor();
        }

        function createFloor() {
            // Don't create floor if in preview mode
            if (isPreviewMode) {
                return null;
            }

            // Remove existing floor if any
            const existingFloor = scene.children.find(
                (child) => child.userData && child.userData.isFloor
            );

            if (existingFloor) {
                scene.remove(existingFloor);
            }

            // Get current background color for floor (based on theme)
            const isDarkMode = document.documentElement.classList.contains("dark");
            const bgColor = new THREE.Color(
                isDarkMode ? themeColors.dark : themeColors.light
            );

            // Create slightly darker color for grid
            const gridColor = bgColor.clone().multiplyScalar(0.8);

            // Create floor with grid
            const floorSize = 20;
            const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);

            // Create grid texture
            const gridSize = 20;
            const gridDivisions = 20;
            const gridCanvas = document.createElement("canvas");
            gridCanvas.width = gridSize;
            gridCanvas.height = gridSize;
            const gridContext = gridCanvas.getContext("2d");

            // Fill with background color
            gridContext.fillStyle = "#" + bgColor.getHexString();
            gridContext.fillRect(0, 0, gridSize, gridSize);

            // Draw grid lines
            gridContext.strokeStyle = "#" + gridColor.getHexString();
            gridContext.lineWidth = 0.5;
            gridContext.beginPath();
            gridContext.moveTo(0, 0);
            gridContext.lineTo(0, gridSize);
            gridContext.stroke();
            gridContext.beginPath();
            gridContext.moveTo(0, 0);
            gridContext.lineTo(gridSize, 0);
            gridContext.stroke();

            // Create texture and make it repeat
            const gridTexture = new THREE.CanvasTexture(gridCanvas);
            gridTexture.wrapS = THREE.RepeatWrapping;
            gridTexture.wrapT = THREE.RepeatWrapping;
            gridTexture.repeat.set(gridDivisions, gridDivisions);

            // Create material with grid texture
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: gridTexture,
                color: bgColor,
                roughness: 0.3,
                metalness: 0.8,
            });

            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1.5;
            floor.userData.isFloor = true; // Mark as floor for future reference
            scene.add(floor);

            return floor;
        }

        function loadFonts() {
            fontLoader = new THREE.FontLoader();
            const fontUrl =
                "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json";
            console.log("Loading font from:", fontUrl);

            fontLoader.load(
                fontUrl,
                function (loadedFont) {
                    console.log("Font loaded successfully");
                    font = loadedFont;
                    createTextMesh("NEON", currentColor);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
                },
                function (error) {
                    console.error("Error loading font:", error);
                    // Fallback to simple cube display if font fails to load
                    displayFallbackCube();
                }
            );
        }

        function displayFallbackCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color(currentColor),
                emissive: new THREE.Color(currentColor),
                emissiveIntensity: 1,
            });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
        }

        function createTextMesh(text, color) {
            // Remove existing text mesh if any
            if (textMesh) scene.remove(textMesh);
            if (glowMesh) scene.remove(glowMesh);

            if (!font) {
                console.warn("Font not loaded yet");
                return;
            }

            try {
                // Add letter spacing by creating individual letters
                if (text.length > 1) {
                    // Group to hold all letters
                    textMesh = new THREE.Group();
                    glowMesh = new THREE.Group();

                    // Calculate total width to center properly
                    let totalWidth = 0;
                    const letterGeometries = [];
                    const spacingFactor = 1.2; // Increase this for more spacing

                    // First pass - create geometries and calculate total width
                    for (let i = 0; i < text.length; i++) {
                        const letterGeometry = new THREE.TextGeometry(text[i], {
                            font: font,
                            size: 0.5,
                            height: 0.08,
                            curveSegments: 12,
                            bevelEnabled: true,
                            bevelThickness: 0.01,
                            bevelSize: 0.01,
                            bevelOffset: 0,
                            bevelSegments: 5,
                        });

                        letterGeometry.computeBoundingBox();
                        const letterWidth =
                            letterGeometry.boundingBox.max.x -
                            letterGeometry.boundingBox.min.x;

                        totalWidth += letterWidth;
                        if (i < text.length - 1)
                            totalWidth += letterWidth * (spacingFactor - 1);

                        letterGeometries.push({
                            geometry: letterGeometry,
                            width: letterWidth,
                        });
                    }

                    // Second pass - position letters and create meshes
                    let currentOffset = -totalWidth / 2;

                    for (let i = 0; i < letterGeometries.length; i++) {
                        const { geometry, width } = letterGeometries[i];

                        // Create text material with tube-like appearance
                        const textMaterial = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(color),
                            emissive: new THREE.Color(color),
                            emissiveIntensity: 1.8,
                            roughness: 0.1,
                            metalness: 0.9,
                        });

                        // Create glow material with improved neon effect
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(color),
                            transparent: true,
                            opacity: 0.7,
                            side: THREE.BackSide,
                        });

                        // Create letter mesh
                        const letterMesh = new THREE.Mesh(geometry, textMaterial);
                        letterMesh.position.x = currentOffset + width / 2;

                        // Create letter glow - improved for better neon effect
                        const glowLetterGeometry = geometry.clone();
                        const glowLetterMesh = new THREE.Mesh(
                            glowLetterGeometry,
                            glowMaterial
                        );
                        glowLetterMesh.position.x = currentOffset + width / 2;
                        glowLetterMesh.scale.set(1.1, 1.1, 1.6); // Increased glow size

                        // Add to groups
                        textMesh.add(letterMesh);
                        glowMesh.add(glowLetterMesh);

                        // Update offset for next letter
                        currentOffset += width * spacingFactor;
                    }

                    scene.add(textMesh);
                    scene.add(glowMesh);
                } else {
                    // For single character, use original approach
                    const textGeometry = new THREE.TextGeometry(text, {
                        font: font,
                        size: 0.5,
                        height: 0.08,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.01,
                        bevelSize: 0.01,
                        bevelOffset: 0,
                        bevelSegments: 5,
                    });

                    textGeometry.center();

                    const textMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(color),
                        emissive: new THREE.Color(color),
                        emissiveIntensity: 1.8,
                        roughness: 0.1,
                        metalness: 0.9,
                    });

                    textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    scene.add(textMesh);

                    // Improved glow effect for single character
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(color),
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.BackSide,
                    });

                    glowMesh = new THREE.Mesh(textGeometry.clone(), glowMaterial);
                    glowMesh.scale.set(1.1, 1.1, 1.6); // Increased glow size
                    scene.add(glowMesh);
                }

                // Update pop score
                calculatePopScore();
            } catch (error) {
                console.error("Error creating text mesh:", error);
                displayFallbackCube();
            }
        }

        function setupEventListeners() {
            // Text input
            document.getElementById("sign-text").addEventListener("input", (e) => {
                createTextMesh(e.target.value || "NEON", currentColor);
            });

            // Font selection
            document
                .getElementById("font-select")
                .addEventListener("change", (e) => {
                    currentFont = e.target.value;
                    const fontUrl = `https://threejs.org/examples/fonts/${currentFont}_regular.typeface.json`;
                    fontLoader.load(fontUrl, function (loadedFont) {
                        font = loadedFont;
                        createTextMesh(
                            document.getElementById("sign-text").value || "NEON",
                            currentColor
                        );
                    });
                });

            // Color buttons
            document.querySelectorAll(".color-btn").forEach((btn) => {
                btn.addEventListener("click", () => {
                    currentColor = btn.dataset.color;
                    document.getElementById("custom-color").value = currentColor;
                    createTextMesh(
                        document.getElementById("sign-text").value || "NEON",
                        currentColor
                    );
                });
            });

            // Custom color
            document
                .getElementById("custom-color")
                .addEventListener("input", (e) => {
                    currentColor = e.target.value;
                    createTextMesh(
                        document.getElementById("sign-text").value || "NEON",
                        currentColor
                    );
                });

            // Effects toggles
            document
                .getElementById("pulse-effect")
                .addEventListener("change", (e) => {
                    isPulsing = e.target.checked;
                    calculatePopScore();
                });

            document
                .getElementById("flicker-effect")
                .addEventListener("change", (e) => {
                    isFlickering = e.target.checked;
                    calculatePopScore();
                });

            document
                .getElementById("reflection-effect")
                .addEventListener("change", (e) => {
                    hasReflection = e.target.checked;
                    calculatePopScore();
                });

            // Preview mode toggle
            document
                .getElementById("preview-mode")
                .addEventListener("change", (e) => {
                    isPreviewMode = e.target.checked;
                    const previewEnvironmentContainer = document.getElementById(
                        "preview-environment"
                    );

                    if (isPreviewMode) {
                        // Show environment options
                        previewEnvironmentContainer.classList.remove("hidden");

                        // Enable preview mode
                        enablePreviewMode();

                        // Set default environment if none selected
                        setEnvironmentBackground(currentEnvironment);
                    } else {
                        // Hide environment options
                        previewEnvironmentContainer.classList.add("hidden");

                        // Disable preview mode
                        disablePreviewMode();
                    }
                });

            // Environment buttons
            document.querySelectorAll(".environment-btn").forEach((btn) => {
                btn.addEventListener("click", () => {
                    currentEnvironment = btn.dataset.environment;

                    // Update button styles
                    document.querySelectorAll(".environment-btn").forEach((b) => {
                        b.classList.remove("ring-2", "ring-offset-2", "ring-indigo-500");
                    });
                    btn.classList.add("ring-2", "ring-offset-2", "ring-indigo-500");

                    // Set environment background
                    setEnvironmentBackground(currentEnvironment);
                });
            });

            // Save button
            document
                .getElementById("save-btn")
                .addEventListener("click", saveDesign);

            // Export button
            document
                .getElementById("export-btn")
                .addEventListener("click", exportPNG);

            // Theme toggle
            document
                .getElementById("theme-toggle")
                .addEventListener("click", toggleTheme);

            // Mobile menu button - improved version
            document.getElementById('mobile-menu-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                const sidebar = document.querySelector('.sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const menuIcon = document.getElementById('menu-icon');
                const mobileBtn = document.getElementById('mobile-menu-btn');

                if (sidebar.classList.contains('open')) {
                    sidebar.classList.remove('open');
                    overlay.classList.remove('open');
                    menuIcon.classList.remove('fa-times');
                    menuIcon.classList.add('fa-bars');
                    mobileBtn.style.left = '1rem';
                } else {
                    sidebar.classList.add('open');
                    overlay.classList.add('open');
                    menuIcon.classList.remove('fa-bars');
                    menuIcon.classList.add('fa-times');
                    mobileBtn.style.left = 'calc(85% - 2rem)';
                }
            });

            // Overlay click to close sidebar
            document.getElementById('sidebar-overlay').addEventListener('click', () => {
                const sidebar = document.querySelector('.sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const menuIcon = document.getElementById('menu-icon');
                const mobileBtn = document.getElementById('mobile-menu-btn');

                sidebar.classList.remove('open');
                overlay.classList.remove('open');
                menuIcon.classList.remove('fa-times');
                menuIcon.classList.add('fa-bars');
                mobileBtn.style.left = '1rem';
            });

            // Click anywhere else to close sidebar (mobile only)
            document.addEventListener('click', (e) => {
                if (window.innerWidth >= 768) return;

                const sidebar = document.querySelector('.sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const menuIcon = document.getElementById('menu-icon');
                const mobileBtn = document.getElementById('mobile-menu-btn');

                // If click is outside sidebar and not on mobile button
                if (!sidebar.contains(e.target) && e.target !== mobileBtn && !mobileBtn.contains(e.target)) {
                    sidebar.classList.remove('open');
                    overlay.classList.remove('open');
                    menuIcon.classList.remove('fa-times');
                    menuIcon.classList.add('fa-bars');
                    mobileBtn.style.left = '1rem';
                }
            });
        }

        function calculatePopScore() {
            // Convert hex color to RGB
            const hex = currentColor.replace("#", "");
            const r = parseInt(hex.substring(0, 2), 16) / 255;
            const g = parseInt(hex.substring(2, 4), 16) / 255;
            const b = parseInt(hex.substring(4, 6), 16) / 255;

            // Calculate brightness (0-1)
            const brightness = Math.sqrt(
                0.299 * r * r + 0.587 * g * g + 0.114 * b * b
            );

            // Calculate color variety (0-1)
            const variety = Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);

            // Calculate base score (0-10)
            let score = brightness * 5 + variety * 3;

            // Add bonuses for effects
            if (isPulsing) score += 1;
            if (isFlickering) score += 0.5;
            if (hasReflection) score += 1;

            // Cap at 10
            score = Math.min(10, score);
            score = Math.round(score * 10) / 10;

            // Update UI
            popScore = score;
            document.getElementById("pop-score").textContent = score.toFixed(1);
            document.getElementById("pop-score-bar").style.width = `${score * 10}%`;
        }

        function toggleTheme() {
            // Toggle dark mode class
            document.documentElement.classList.toggle("dark");
            const isDarkMode = document.documentElement.classList.contains("dark");
            localStorage.setItem("darkMode", isDarkMode);

            if (isPreviewMode) {
                // In preview mode, we don't want to change the background or show the floor
                // Just adjust the lighting to match the new theme
                adjustLightingForPreviewWithTheme(isDarkMode);
            } else {
                // In regular mode, update scene background
                scene.background = new THREE.Color(
                    isDarkMode ? themeColors.dark : themeColors.light
                );

                // Update floor to match new theme with grid
                createFloor();
            }
        }

        function adjustLightingForPreviewWithTheme(isDarkMode) {
            // Adjust lighting in preview mode when theme changes
            const ambientLight = scene.children.find(
                (child) => child instanceof THREE.AmbientLight
            );

            const pointLight = scene.children.find(
                (child) => child instanceof THREE.PointLight
            );

            if (ambientLight && pointLight) {
                if (isDarkMode) {
                    // Slightly reduce ambient light in dark mode
                    ambientLight.intensity = Math.max(
                        0.3,
                        ambientLight.intensity - 0.2
                    );
                } else {
                    // Slightly increase ambient light in light mode
                    ambientLight.intensity = Math.min(
                        0.8,
                        ambientLight.intensity + 0.2
                    );
                }
            }
        }

        function saveDesign() {
            const signText = document.getElementById("sign-text").value || "NEON";
            const design = {
                text: signText,
                color: currentColor,
                font: currentFont,
                effects: {
                    pulsing: isPulsing,
                    flickering: isFlickering,
                    reflection: hasReflection,
                },
                popScore: popScore,
                timestamp: Date.now(),
            };

            // Get existing designs or initialize empty array
            let savedDesigns = JSON.parse(
                localStorage.getItem("neonDesigns") || "[]"
            );
            savedDesigns.push(design);
            localStorage.setItem("neonDesigns", JSON.stringify(savedDesigns));

            // Refresh the saved designs display
            loadSavedDesigns();

            // Show success message
            showToast("Design saved successfully!", "success");
        }

        function loadSavedDesigns() {
            const savedDesignsContainer = document.getElementById("saved-designs");
            savedDesignsContainer.innerHTML = "";

            const savedDesigns = JSON.parse(
                localStorage.getItem("neonDesigns") || "[]"
            );

            savedDesigns.forEach((design, index) => {
                const designElement = document.createElement("div");
                designElement.className =
                    "p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white text-sm cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600";
                designElement.innerHTML = `
                <div class="truncate" style="color: ${design.color}">${design.text
                    }</div>
                <div class="flex justify-between items-center mt-1">
                    <span>${design.popScore.toFixed(1)}⭐</span>
                    <button class="delete-design text-red-500 hover:text-red-700" data-index="${index}">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;

                // Load design on click
                designElement.addEventListener("click", (e) => {
                    if (!e.target.closest(".delete-design")) {
                        loadDesign(design);
                    }
                });

                savedDesignsContainer.appendChild(designElement);
            });

            // Add event listeners to delete buttons
            document.querySelectorAll(".delete-design").forEach((btn) => {
                btn.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const index = parseInt(btn.dataset.index);
                    savedDesigns.splice(index, 1);
                    localStorage.setItem("neonDesigns", JSON.stringify(savedDesigns));
                    loadSavedDesigns();
                    showToast("Design deleted", "info");
                });
            });
        }

        function loadDesign(design) {
            document.getElementById("sign-text").value = design.text;
            currentColor = design.color;
            document.getElementById("custom-color").value = design.color;
            currentFont = design.font;
            document.getElementById("font-select").value = design.font;

            // Load font and update text
            const fontUrl = `https://threejs.org/examples/fonts/${currentFont}_regular.typeface.json`;
            fontLoader.load(fontUrl, function (loadedFont) {
                font = loadedFont;
                createTextMesh(design.text, design.color);

                // Update effects
                isPulsing = design.effects.pulsing;
                isFlickering = design.effects.flickering;
                hasReflection = design.effects.reflection;

                document.getElementById("pulse-effect").checked = isPulsing;
                document.getElementById("flicker-effect").checked = isFlickering;
                document.getElementById("reflection-effect").checked = hasReflection;

                calculatePopScore();
            });

            showToast("Design loaded", "success");
        }

        function exportPNG() {
            // Store original camera position and scene settings
            const originalCameraPosition = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
            };

            // Temporarily position camera for a good capture angle if not in preview mode
            if (!isPreviewMode) {
                // Move camera to front-facing position for better screenshot composition
                camera.position.set(0, 0, 3.5);
                camera.lookAt(0, 0, 0);
            }

            // Make sure everything is rendered before capture
            if (controls) controls.update();
            if (renderer && scene && camera) renderer.render(scene, camera);

            // Capture the canvas directly from the Three.js renderer
            try {
                // Create a name for the file
                const text = document.getElementById("sign-text").value || "NEON";
                const environment = isPreviewMode ? `-${currentEnvironment}` : "";
                const timestamp = Date.now();
                const filename = `neon-sign-${text
                    .replace(/\s+/g, "-")
                    .toLowerCase()}${environment}-${timestamp}.png`;

                // Get image data directly from the renderer
                const imgData = renderer.domElement.toDataURL("image/png");

                // Create download link
                const link = document.createElement("a");
                link.download = filename;
                link.href = imgData;

                // Append to document, click and remove
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Show success message
                showToast("Screenshot captured!", "success");
            } catch (error) {
                console.error("Error exporting PNG:", error);
                showToast("Failed to export image", "error");
            }

            // Restore camera position if it was temporarily changed
            if (!isPreviewMode) {
                camera.position.set(
                    originalCameraPosition.x,
                    originalCameraPosition.y,
                    originalCameraPosition.z
                );
            }
        }

        // Toast notification function
        function showToast(message, type = "info") {
            // Create toast element
            const toast = document.createElement("div");
            toast.className = `fixed bottom-4 right-4 px-4 py-2 rounded-lg text-white z-50 ${type === "success"
                    ? "bg-green-500"
                    : type === "error"
                        ? "bg-red-500"
                        : "bg-blue-500"
                } shadow-lg transition-opacity duration-300 flex items-center`;

            // Add icon based on type
            let icon = "";
            if (type === "success")
                icon = '<i class="fas fa-check-circle mr-2"></i>';
            else if (type === "error")
                icon = '<i class="fas fa-exclamation-circle mr-2"></i>';
            else icon = '<i class="fas fa-info-circle mr-2"></i>';

            toast.innerHTML = `${icon}${message}`;

            // Add to document
            document.body.appendChild(toast);

            // Remove after 3 seconds
            setTimeout(() => {
                toast.style.opacity = "0";
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (textMesh && glowMesh) {
                // Handle pulsing effect
                if (isPulsing) {
                    const pulseIntensity = 0.5 + 0.5 * Math.sin(Date.now() * 0.002);

                    // Check if textMesh is a group (multiple letters) or a single mesh
                    if (textMesh.isGroup) {
                        // Apply to each letter
                        textMesh.children.forEach((child) => {
                            child.material.emissiveIntensity = 1.6 + pulseIntensity * 0.6;
                        });
                        glowMesh.children.forEach((child) => {
                            child.material.opacity = 0.5 + pulseIntensity * 0.3;
                            // Subtle scale pulsing
                            const pulseScale = 1.0 + pulseIntensity * 0.07;
                            child.scale.set(
                                1.1 * pulseScale,
                                1.1 * pulseScale,
                                1.6 * pulseScale
                            );
                        });
                    } else {
                        // Apply to single mesh
                        textMesh.material.emissiveIntensity = 1.6 + pulseIntensity * 0.6;
                        glowMesh.material.opacity = 0.5 + pulseIntensity * 0.3;
                        // Animate glow size for better effect
                        const pulseScale = 1.0 + pulseIntensity * 0.07;
                        glowMesh.scale.set(
                            1.1 * pulseScale,
                            1.1 * pulseScale,
                            1.6 * pulseScale
                        );
                    }
                } else {
                    // Reset to normal intensity when not pulsing
                    if (textMesh.isGroup) {
                        textMesh.children.forEach((child) => {
                            child.material.emissiveIntensity = 1.8;
                        });
                        glowMesh.children.forEach((child) => {
                            child.material.opacity = 0.7;
                            child.scale.set(1.1, 1.1, 1.6);
                        });
                    } else {
                        textMesh.material.emissiveIntensity = 1.8;
                        glowMesh.material.opacity = 0.7;
                        glowMesh.scale.set(1.1, 1.1, 1.6);
                    }
                }

                // Handle flicker effect - more realistic neon flickering
                if (isFlickering && Math.random() < 0.008) {
                    const flickerDuration = 50 + Math.random() * 150;
                    const flickerIntensity = 0.3 + Math.random() * 0.7;

                    // Apply flicker based on mesh type
                    if (textMesh.isGroup) {
                        // Store original values
                        const originalIntensities = textMesh.children.map(
                            (child) => child.material.emissiveIntensity
                        );
                        const originalOpacities = glowMesh.children.map(
                            (child) => child.material.opacity
                        );

                        // Apply flicker to each letter
                        textMesh.children.forEach((child, index) => {
                            child.material.emissiveIntensity *= flickerIntensity;
                        });
                        glowMesh.children.forEach((child, index) => {
                            child.material.opacity *= flickerIntensity;
                        });

                        // Restore original values after duration
                        setTimeout(() => {
                            textMesh.children.forEach((child, index) => {
                                child.material.emissiveIntensity = originalIntensities[index];
                            });
                            glowMesh.children.forEach((child, index) => {
                                child.material.opacity = originalOpacities[index];
                            });
                        }, flickerDuration);
                    } else {
                        // Store original values for single mesh
                        const originalIntensity = textMesh.material.emissiveIntensity;
                        const originalOpacity = glowMesh.material.opacity;

                        // Apply flicker
                        textMesh.material.emissiveIntensity *= flickerIntensity;
                        glowMesh.material.opacity *= flickerIntensity;

                        // Restore original values after duration
                        setTimeout(() => {
                            textMesh.material.emissiveIntensity = originalIntensity;
                            glowMesh.material.opacity = originalOpacity;
                        }, flickerDuration);
                    }
                }
            }

            if (controls) controls.update();
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        function enablePreviewMode() {
            // Save current camera position
            originalCameraPosition = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
            };

            // Position camera to face the neon sign directly
            camera.position.set(0, 0, 3);
            camera.lookAt(0, 0, 0);

            // Keep full camera controls - allow rotation as requested
            // Only adjust zoom limits for better viewing
            controls.minDistance = 2;
            controls.maxDistance = 6;

            // Hide the floor
            const floor = scene.children.find(
                (child) => child.userData && child.userData.isFloor
            );

            if (floor) {
                floor.visible = false;
            }

            // Set default environment background
            setEnvironmentBackground(currentEnvironment);
        }

        function disablePreviewMode() {
            // Restore camera position
            camera.position.set(
                originalCameraPosition.x,
                originalCameraPosition.y,
                originalCameraPosition.z
            );

            // Restore camera controls to original values
            controls.minDistance = originalControlsState.minDistance;
            controls.maxDistance = originalControlsState.maxDistance;

            // Remove any environment background
            const existingBg = scene.children.find(
                (child) => child.userData && child.userData.isBackground
            );

            if (existingBg) {
                scene.remove(existingBg);
            }

            // Restore the original background color based on theme
            const isDarkMode = document.documentElement.classList.contains("dark");
            scene.background = new THREE.Color(
                isDarkMode ? themeColors.dark : themeColors.light
            );

            // Recreate floor with grid only if not in preview mode
            createFloor();
        }

        function setEnvironmentBackground(environment) {
            if (!isPreviewMode) return;

            // Load environment texture
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(environmentImages[environment], function (texture) {
                // Create a large sphere to serve as the environment
                const bgGeometry = new THREE.SphereGeometry(500, 60, 40);
                // Flip the geometry inside out
                bgGeometry.scale(-1, 1, 1);

                const bgMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                });

                // Remove existing background sphere if any
                const existingBg = scene.children.find(
                    (child) => child.userData && child.userData.isBackground
                );

                if (existingBg) {
                    scene.remove(existingBg);
                }

                const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
                bgMesh.userData.isBackground = true;
                scene.add(bgMesh);

                // Adjust the lighting to match the environment
                adjustLightingForEnvironment(environment);
            });
        }

        function adjustLightingForEnvironment(environment) {
            // Adjust lighting based on the environment
            const ambientLight = scene.children.find(
                (child) => child instanceof THREE.AmbientLight
            );

            const pointLight = scene.children.find(
                (child) => child instanceof THREE.PointLight
            );

            if (ambientLight && pointLight) {
                switch (environment) {
                    case "diner":
                        ambientLight.intensity = 0.7;
                        pointLight.intensity = 1.2;
                        pointLight.color.set(0xffffcc); // Warm light
                        break;
                    case "cyberpunk":
                        ambientLight.intensity = 0.3;
                        pointLight.intensity = 1.5;
                        pointLight.color.set(0x00ffff); // Cyan light
                        break;
                    case "festival":
                        ambientLight.intensity = 0.5;
                        pointLight.intensity = 1.8;
                        pointLight.color.set(0xff00ff); // Magenta light
                        break;
                }
            }
        }
    </script>
</body>

</html>